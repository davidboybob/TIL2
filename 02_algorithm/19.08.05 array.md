# 2. 배열



#### 2차 배열

  각 행에 해당되는 열의 리스트 크기는 같아야 합니다. 

(파이썬에서는 다르더라도 오류는 발생하지 않습니다.)



행우선, 열우선, 대각, 특정위치에 대해서 비교 및 계산(패턴)



#### 행 우선 순회 

 ```python
# i 행의 좌표
# j 열의 좌표
# n x m 이 같을때 는 상관 없지만 두 크기가 다를때 주의!
for i in range(len(Array)):
    for j int range(len(Array[i])):
        Array[i][j]
 ```

#### 열 우선 순회

```python
for j in range(len(Arrray[0])):
    for i in range(len(Array)):
        Array[i][j]
```

#### 지그재그 순회

```python
for i in range(len(Array)):
    for j in range(len(Array[0])):
        Array[i][j + (m-1-2*j) * (i%2)]
```

```python
N = 10 
for i in range(N):
    if i % 2 == 0:
        for j in range(N):
            pass
        else:
            for j in range(N-1, -1, -1):
                pass
```



#### 전치행렬 

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬


for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```



2차원 배열의 접근,델타를 이용한 2차 배열 탐색

```python
N = 10 # N x N
dx = [-1, +1, 0, 0]
dy = [0, 0, -1, +1]

for x in range(N): # 모든 행에 대해서
    for y in range(N):
        #[x][y]
        #4방향의 인접 위치 좌표를 생성
        for i in range(4):
            tx, ty = x + dx[i], y +dy[i]
            #경계 체크
            if tx < 0 or tx == N or ty < 0 or ty == N: 
                continue
```



#### 대각 탐색

arr = [

]

N, M = len



2차배열 탐색

#### 부분집합

부분집합 합 문제 : 2^n 의 시간 복잡도 => 어려운 문제



부분집합 : 2^n 를 2진수로  비트 표현으로 나타낼수 있다.

​					10진수 비트표현으로도 나타낼 수 있다.



{1, 2, 3} 의 부분집합표현

| 집합    | 2진수 | 10진수 |
| ------- | ----- | ------ |
| 0       | 000   | 0      |
| {1}     | 100   | 4      |
| {2}     | 010   | 2      |
| {3}     | 001   | 1      |
| {1,2}   | 110   | 6      |
| {1,3}   | 101   | 5      |
| {2,3}   | 011   | 3      |
| {1,2,3} | 111   | 7      |



#### 비트 연산자 (비트 오퍼레이션)

가장 연산이 빠르다. 비트단위 연산이 다른 연산자에 비해서 연산속도가 빠르다.

AND OR NOT SHIFT EXCLUSIVE

| 10진수 | 2진수  | 16진수 |
| ------ | ------ | ------ |
| 10     | 0b1010 | 0xa    |

2진수 AND 2진수

2진수 OR 2진수



a << 1  왼쪽으로 1칸씩 땡기기 (1칸 마다 2배씩 커진다. 2^n배 )

1010 => 10100 : 10 << 20 << 40 << 80 

| 10<<1           | 10<<2           | 10<<3            |
| --------------- | --------------- | ---------------- |
| 1010<<1 = 10100 | 1010<<2 = 10100 | 1010<<3 = 101000 |
| 10              | 20              | 40               |
| **10>>1**       | **10>>2**       | **10>>3**        |
| 1010>>1 = 101   | 1010>>2 = 10    | 1010>>3 = 1      |
| 5               | 2               | 1                |

비트 오퍼레이터 => 부분집합 생성하는 방법에 적용가능하다.

```python
arr = [3, 6, -2, 7, -3, 1, -5, -1, 5, 4]

N = len(arr)

for i in range(1 << N): #i 는 부분집합을 표현하는 값을 의미
    Sum = 0
    for j in range(N):
        if i & (1 << j): # arr[j]를 포함하는지
            print(arr[j], end=' ')
        print()
    print()
```



#### 인덱스

