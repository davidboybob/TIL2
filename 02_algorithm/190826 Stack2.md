[TOC]

# Stack2



## 1. 계산기

### 중위 표기법 : ex) A+B

### 후위 표기법 : ex) AB+ 

- 컴퓨터가 이해하기 쉬움
- 



중위표기식 후위표기식 변환방법 : 스택에 연산자가 들어간다.

`A*B-C/D  ==> AB*CD/-`  

후위표기식을 계산할 때 : 스택에 피연산자가 들어간다.

문자열로된 수식을 계산하는 함수 

eval() : evaluation



## 2. 백트래킹

백트래킹  vs DFS 

DFS는 모든 경로를 추적, but 백트래킹은 불필요한 경로를 조기에 차단

N! 는 DFS 불가능. => 백트래킹으로 추적

최악의 경우 백트래킹도 O(n!) 시간복잡도를 가짐.



### 백트래킹 절차

1. 상태공간 트리의 깊이 우선 검색을 실시한다.
2. 각 노드가 유망한지를 점검한다.
3. 만일 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.



## 3. 부분집합 구하기

어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자 하는 어떤 집합의 원소 개수가 n일경우 부분집합의 개수는 2<sup>n</sup>이 나온다.

- N이 커지면 경우의 수가 많아질 때 백트래킹을 이용하자.

- 백트래킹 과정

  ```python
  def backtrack(a, k, input):
      global MAXCANDIDATES
      c = [0] * MAXCANDIDATES
      if k == input:
          process_solution(a, k)
      else:
          k += 1
          ncandidates = construct_candidates(a, k, input, c)
          for i in range(ncandidates):
              a[k] = c[i]
              backtrack(a, k, input)
  
  
  def construct_candidates(a, k, input, c):
      c[0] = True
      c[1] = False
      return 2
  
  def process_solution(a, k):
      print('(', end='')
      for i in range(k+1):
          if a[i]:
              print(i, end='')
      print(')')
  
  MAXCANDIDATES = 100
  NMAX = 100
  a=[0] * NMAX
  backtrack(a, 0, 3)
  ```

  

- 백트래킹을 이용하여 순열 구하기

  <sub>4</sub>P<sub>4</sub> = 4!

  <sub>4</sub>C<sub>2</sub> = 

- ex) {a, b, c, d} 로 구성된 집합 

  ```py
  def construct_candidates():
  ```

  재귀함수형태의 백트래킹 주의 사항. 

  끝날 지점을 정해줘야 함.



## 4.분할정복 알고리즘

- 주어진문제의 입력을 다루기 쉽게 부분으로 분할하여 문제를 해결하는 방식의 알고리즘

- 문제를 더이상 나눌 수 없을 때까지 나누고 이렇게 나우저니 문제들을 각각 풂으로써 전체 문제의 답을 얻는 알고리즘

- 단계 : 1)분할, 2)정복을 나누어서 해겨하는 것.

- 분할한 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산하며 이들의 해를 ㅟ합하여 원래문제의 해를 얻음

:warning: 엄청나게 크고 방대한 문제를 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 다음 그것들을 다시 합쳐서 해결

### 퀵정렬, 병합정렬

퀵정렬 : 평균적으로 수행속도가 매우 빠른 정렬 방법

정렬할 전체 데이터에 대해서 정렬ㄹ을 수행하지 않고 기준키를 중심으로 왼쪽 부분 리스트와 오른쪽 부분 리스트로 분할하여 정렬

이때 기준이 되는 기준키를 피벗(pivot)이라고 함

피벗을 기준으로 왼쪽 부분 리스트에는 피벗보다 작은 데이터들을 이동시키고 오른쪽 부분 리스트에는 피벗보다 큰 데이터들을 이동

작은 값을 갖는 데이터와 큰 값을 갖는 데이터로 분리해가며 정렬하는 방법

프로그램에서 순환호출을 이용하기 떄문에 스택이 필요.



 피벗의 선택 방법

- 전체 데이터 중 가운데 위치한 데이터
- 첫번째 데이터
- 마지막 데이터 



합병 정렬 : (merge sort)

분할과 합병을 반복하는 과정에서 합병시 크기를 비교하여 작은값을 먼저 합병하고, 인덱스를 증가하면서 결국 하나의 리스트로 합병되는데, 이때 원소들은 이미 정렬되어 있는 상태이다.







