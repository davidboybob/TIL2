자료형 C 언어적인 특징들이 파이썬에 많이 녹아져 있음. 연산자 값과 연산자 산술 연사자 비교 연산자 논리 연산자 컴퓨터가 하는 일

컴퓨터 자료형이 중요. 자료형 --> 1. 자료의 표현 

   2. 자료의 계산

   3. 실수의 표현 123.456 

      자료를 저장한다는것은 자료형이 필요 ==>	이해가 필요 





주 1장씩 진행

월요일에는 교재 내용을 공부 + 실습문제 1개

화요일에는 실습 + 실습문제 4개 + 추가 1개



전산전공 아니기 떄문에 자료구조 알고리즘 과목 프로그래밍 언어 배우고, 자료구조 배우고 알고리즘 배운다. 보통 

​	

​	저장하는 방법 어떻게 저장하면 좋을지



자료를 구축하고 메모리에 저장하는 효율적인 방법 





### 추상 자료형(Abstract Data Type)

List(배열) 논리적 개념

Stack Queue Tree Graph



문제 풀때 라이브러리 사용하지 않는다. List 사용할 때 max(), min(), index(),sort()

슬라이싱 쓰지말기



쓰지 말고, 공부할 때 



기본적인 모든 로직을 구현해 보는 것이 좋다. 



코딩할 떄 쓰는 언어적 표현

- for, while(반복), if-else(분기) 이거 말고 쓰이는 게 없다. 
- 수식은 피연산자와 연산자 
- 함수호출도 수식 



일일이 구현해보고 장단점 파악, 잘 알고 씨는 것 

for  append 



## <알고리즘>

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

- 간단한게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.



​	같은 일을 하는 서로 다른 코드들 중에 어떤 것이 더 좋은 코드인가?? = 효율적인 알고리즘



ex) 1~100까지의 합을 구하는 문제

슈더코드와 순서도

```python
def CalcSum(n):
    sum = 0
    for i in range(1, n+1):
        sum += sum + i
    return sum
```



![1564367737983](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564367737983.png)



2. #### 알고리즘 성능은 무엇으로 측정하는가

- aps과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.



- 무엇이 좋은 알고리즘인가?

  - 정확성  얼마나 정확하게 동작하는가
  - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가 : CPU할당량 ==> 시간과 관련
  - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가 (자료를 구동하는 데 있어서 필요한 메모리)
  - 단순성 : 얼마나 단순한가
  - 최적성 : 더 이상 개선할 여지없이 최적화 되었는가 (효율성 UP)

  결론 : 알고리즘은 결국 컴퓨팅 작업인데  컴퓨팅 자원을 이용해서 구동.

  ​			cpu 메모리  => 적게 쓰면서 정확하게 구동되는 것을 효율적이다 라고 말함.



문제 크기와 관련이 있음



#### **시간 복잡도 (Time Complexity)**

<**빅-오 표기법**>

실행 횟수 구하기  다항식형태의 알고리즘 표현식으로 표현하기 

가장 차수가 높은 것만 남기고 버리기



O(3n +2) = O(3n) = O(n)

​					최고차항 		계수 제거

​					선택

​         

for문이 2번 반복 ==> a*n^2 + b*n + c

for문이 3번 반복 ==> a*n^3 + b*n^2 + c*n + d

== n이 커지면 결국 반복횟수가 엄청 많아지는데, 차수가 가장 높은 항이 제일 중요.

빅오 :  O() 최악의 경우          최악 : 제일 마지막에 있거나 아예 없거나  --->  n번   가장 나쁜 케이스를 알기 떄문에 예측을 정확하게 할 수 있다.  제일 많이 씀. 최악이 중요

오메가 :  Ω () 최선의 경우      최선 : 제일 처음에 있을떄  --> 1번

씨타 : θ() 최선 최악이 같을 때 씀. (교집합)  O() 와 같다고 생각해도 무관



검색 List 

- 순차탐색  : n이 많아지면 효율성이 떨어짐

​						n개 

||||||||||||||| ... ||||||||||||

​     ^

-  이진 탐색 	  정렬이 되어있다고 가정하고, 추측을 해서 찾아 갈 수 있음.

> 중간찍기 	1번 확인 후 필요 없는 영역을 버리기 
>
> 반씩 떨구기

> log<sub>2</sub> n 번만 하면 됨  분할전공 알고리즘 

<sup> 제곱쓰기  // <sub> 아래숫자 (로그)

직접 작성한 코드에 대해서 내가 해결하고자 하는 시간 복잡도를 가지는 알고리즘이다라고 하는 것을 알고 있어야합니다.

 이런 방법은 대략 시간복잡도가 이정도 되는 것을 이해하는 것을 말합니다.

O(1) : 항상 시간이 일정 == 최상의 알고리즘 // 해싱이라는 알고리즘 

O(n) : 반복 1번 중첩

O(n<sup>2</sup>) : 반복 2번 중첩

O(n<sup>3</sup>) : 반복 3번 중첩



O(nlogn)알고리즘 : 정렬알고리즘 == 빠름빠름 



컴퓨터 입장에서 실행시간이 매우 많이 필요한 문제 = NP 

NP vs P 

어렵 vs 쉬움



---

대량의 데이터를 처리하기 위해서는 O() 의 처리 속도가 중요하다. 





배열 : 메모리 배열 포인터 어레이



정렬 : 크기 비교 == 자료형이 같아야 함.

버블정렬

 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

한단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

교환하며 이동하는 모습이 물 위에 올라오는 거품모양 



완전탐색 : 가능한 모든 경우의  수를 따진다.5

결정문제 : 

최적화 문제 : 최대 혹은 최소가 되는 경우를 찾는 문제



